% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/3_classes.R
\docType{class}
\name{SM.dlm-class}
\alias{SM.dlm-class}
\alias{SM.dlm}
\title{Class SM.dlm --- An S4 class to represent the unfiited dynamic linear model for raw signal}
\description{
SM.dlm class contrains the model defition based on the timeseries structure.
}
\section{objects from the Class}{

Objects are created by the method \code{\link{buildClass}} or by calls of the form SM.dlm(...). However,
the first form is recommended.
}

\section{Slots}{

\describe{
  \item{\code{call}}{An object of class \code{\link[base]{call}} returning an unevaluated function call.}
  \item{\code{freq}}{Positive integer value indicating the stationality of the raw inputs. Set it to 1 if the
        inputs has no stationality.}
  \item{\code{indicators}}{A list containing outliers or human intervention indexes, see examples.}
  \item{\code{lagMax}}{An integer value indicating the maximum effect lag for each outlier, see Details.}
  \item{\code{verify}}{A logical value indicating whether the validation process should be applied,
   see Details.}
  \item{\code{parallel}}{A logical value indicating whether the parallel process should be applied.}
}
}

\section{Details}{

 Usually, outliers are happened in the data due to uncontrollable event or human intervention.
 In those cases, one should annotate the indexes where it presents to validate the model.
 check the example for more application detail.

 Once outlier happended, its effect could be instant or remains some time period in case of timeseries. If
 lagMax is bigger than 1, then gridsearch will be applied: for each outlier index and for each possible
 lag between one and lagMax, the maximun likelihood estimation will be calculated for each possible
 combination. Then, best model will be returned after the gridsearch process which has the best MLE
 performance.

 The number of models is determinated by follow equation: \deqn{number of models = lagMax ** number of indicators.}
 According to the formula, the gridsearch complexitity is an exponential
 function respect a #indicators with base lagMax. To avoid computation problem, it's best to assign verify
 equal to TRUE, where it returns FALSE if #indicators ** lagMax >= 200 in the class definition.
 To skip this validation process, kindly set verify to FALSE.
}

\section{Methods}{

Available methods for this class are: \itemize{
 \item \code{\link{show}}: the class display is simplyfied, each data input is limited to 25;
 \item \code{\link{print}}: displays the whole class;
 \item \code{\link{get}} (`[`): returns the value of a slot;
 \item \code{\link{fit}}: training the model and returning the \code{\link{SM.dlm.fitted}}.
 \item \code{\link{extractMeasures}}: returning error, because the model hasn't trained.
}
}

\section{Extends}{

From class \code{\link{SM-class}}, directly.
}

\examples{
n <- 50
rs.class <- RS(sigb = rnorm(n, mean = 0, sd = 1),
               epsb = rnorm(n, mean = 0, sd = 2),
               epsp = rnorm(n, mean = 1, sd = 1))
# The inputs we created are random variable,
# then they have non-stationality structure.
freq <- 1
# Suppose there is a rain at index 1 and 20, and irrigation at 5.
index <- list(rain = c(1, 20), watering = c(5))
lagMax <- 10
verify <- parallel <- TRUE
\dontrun{
# it returns error because 10 ** 3 = 1000 which is bigger than 200.
dlm.class <- buildClass(object = rs.class, method = "dlm",
                        freq = freq, ind = index, lagMax = lagMax,
                        verify = verify, parallel = parallel)
}
lagMax <- 3
dlm.class <- buildClass(object = rs.class, method = "dlm",
                        freq = freq, ind = index, lagMax = lagMax,
                        verify = verify, parallel = parallel)
dlm.class

}
